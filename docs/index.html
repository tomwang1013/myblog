<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>今歌爸爸的学习记录及生活点滴</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="web开发，前端技术总结">
<meta name="keywords" content="front-end, web development">
<meta property="og:type" content="website">
<meta property="og:title" content="今歌爸爸的学习记录及生活点滴">
<meta property="og:url" content="http://jinge.red/index.html">
<meta property="og:site_name" content="今歌爸爸的学习记录及生活点滴">
<meta property="og:description" content="web开发，前端技术总结">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="今歌爸爸的学习记录及生活点滴">
<meta name="twitter:description" content="web开发，前端技术总结">
  
    <link rel="alternate" href="/atom.xml" title="今歌爸爸的学习记录及生活点滴" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">今歌爸爸的学习记录及生活点滴</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jinge.red"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-offline-cookbook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/offline-cookbook/" class="article-date">
  <time datetime="2018-10-12T04:49:24.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/offline-cookbook/">offline-cookbook总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook" target="_blank" rel="noopener">offline cookbook</a>是关于service worker缓存及响应策略很好的文章，这里画个图总结一下：</p>
<p><img src="..\images\offline-cookbook.png" alt="offline cookbook"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/offline-cookbook/" data-id="cjn5lo78800057ovjitikq9wb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwa/">pwa</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-csrf-xss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/csrf-xss/" class="article-date">
  <time datetime="2018-09-02T04:49:24.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/csrf-xss/">CSRF和XSS扫盲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于CSRF和XSS的文章非常多，相信很多人也看过了，笔者也看了一些，但总是记不住，这个做个非常简单的总结，让大家有个直观的印象</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>全称：Cross-Site Request Forgery，以用户的名义发起一个恶意请求，简单过程如下：</p>
<ol>
<li>用户登录正常网站A</li>
<li>用户同时不小心打开黑客的网站B</li>
<li>网站B自动或由用户触发发起一个恶意的指向A服务器的请求</li>
<li>A服务器处理这个恶意请求，坏事发生</li>
</ol>
<p>这里有幅网上找的图可以看出这个过程：</p>
<p><img src="../images/csrf.png" alt="img"></p>
<h3 id="如何避免？"><a href="#如何避免？" class="headerlink" title="如何避免？"></a>如何避免？</h3><p>避免的关键是如何区分甄别出恶意请求：目前比较好的一种做法是为每个请求带上一个随机的token，这个token是服务器端和浏览器端通过某种方式约定好的，服务器端通过检查这个token来验证请求的合法性，这个很多后端框架都做了支持。</p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>全称：Cross-site Scripting，想方设法在用户浏览的网页上植入恶意脚本，既然是脚本，就可以做任何事：获取隐私(cookie等)、打开其他网站、修改页面内容等等</p>
<p>怎么植入恶意脚本呢？举两个例子：</p>
<ol>
<li><p>下面是一段JSP脚本，将来自当前页面url中的一个参数展示在页面上：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;% String eid = request.getParameter(<span class="string">"eid"</span>); %&gt; </span><br><span class="line">Employee ID: &lt;%= eid %&gt;</span><br></pre></td></tr></table></figure>
<p>攻击者可以先准备一个url，在eid参数中存入恶意脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://webpage.com/?eid=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后引诱用户点击这个url，引诱的方式很多，如email，SNS等。用户一点击，脚本执行</p>
</li>
<li><p>又是一段JSP脚本，在数据库中查找一个名称，然后展示出来：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">	ResultSet rs = stmt.executeQuery(<span class="string">"select * from emp where id="</span> + id);</span><br><span class="line">	<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	rs.next(); </span><br><span class="line">   	 	String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">Employee Name: &lt;%= name %&gt;</span><br></pre></td></tr></table></figure>
<p>如果这个名称是用户输入的，且正常情况下其他用户可以通过浏览网页看到这个信息，那么攻击者可以输入一段恶意脚本作为名称，这个名称被存入数据库中，所有用户都可能看到，所以很多用户都会受到攻击</p>
</li>
</ol>
<p>由此可以看到，XSS一般是外部输入直接展示在页面上导致的，所以解决的办法就是对外部输入进行严格的验证，必要时对输入内容进行转码，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt; =&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; // html entity encode</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/csrf-xss/" data-id="cjn5lo78700047ovjn55w8bfb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全/">安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-code-splitting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/code-splitting/" class="article-date">
  <time datetime="2018-08-22T04:49:24.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/code-splitting/">javascript优化之code splitting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>tree shaking</code>指的是去掉没用到的代码，减小js文件体积从而提高加载速度；而<code>code splitting</code>指的是如何将js代码分解成不同的js文件，使得页面在打开时只加载必要的js文件，从而提高页面加载速度。</p>
<p>大概有以下三种分解方式：</p>
<h3 id="Vendor-splitting"><a href="#Vendor-splitting" class="headerlink" title="Vendor splitting"></a>Vendor splitting</h3><p>将第三方代码(vendor code)和应用程序的代码分开来，使用不用的缓存策略，使得它们互不影响。我们<strong>始终</strong>都应该这么做</p>
<h3 id="Entry-point-splitting"><a href="#Entry-point-splitting" class="headerlink" title="Entry point splitting"></a>Entry point splitting</h3><p>对于多页面应用，应该按页面打包js，并将各个页面的公共js提取出来作为单独的js文件进行加载</p>
<h3 id="Dynamic-splitting"><a href="#Dynamic-splitting" class="headerlink" title="Dynamic splitting"></a>Dynamic splitting</h3><p>使用动态js加载语法，在页面首次打开后，在后面的操作过程中按需加载js，比如根据用户状态或模块切换动态加载相关js，提高页面首屏渲染速度</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/code-splitting/" data-id="cjn5lo78000017ovj0pbrtzkg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-crp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/crp/" class="article-date">
  <time datetime="2018-08-22T04:49:24.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/crp/">深入理解浏览器关键渲染路径(critical render path)及其优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>web性能分析通常都是基本理论+反复实践，没有一套统一的标准或方法。以我的经验来看，我们或多或少都知道一些或几点相关理论，但都是很片段很零碎的，不太好总结或关联起来。本文尝试在<code>critical render path</code>(后简称crp)上做一个分析总结。</p>
<h3 id="什么是crp？"><a href="#什么是crp？" class="headerlink" title="什么是crp？"></a>什么是crp？</h3><p>crp是和浏览器首屏渲染有关的，指的是浏览器在渲染首屏之前需要经过哪些关键步骤。我们知道，首屏渲染速度是性能的一个重要指标，我们应该让用户在打开页面后尽快看到东西出来。要做到这一点，需要深入分析并优化crp，让这些关键步骤所花时间最小。第一步，我们先看看浏览器是如何渲染页面的</p>
<h3 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h3><p>这算是一个基本理论，每个浏览器渲染页面都要经过一个基本相同的过程：</p>
<p><img src="../images/1537495003079.png" alt="1537495003079"></p>
<ol>
<li>解析html构建DOM</li>
<li>解析css构建CSSOM（和第一步同时进行）</li>
<li>将DOM和CSSOM合起来构建渲染树</li>
<li>根据渲染树，计算每个元素在窗口中的确切位置和大小</li>
<li>执行渲染</li>
</ol>
<p>我们以一个例子来详细说明这几个步骤，考虑下面一段html：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一步解析html，生成DOM：</p>
<p><img src="../images/1537495651317.png" alt="1537495651317"></p>
<p>第二步解析css，生成CSSOM：</p>
<p>DOM告诉了我们页面的结构，但是没有样式信息，所以下一步就是解析css，也会生成一个树状结构，这是因为css具有继承特性，子元素或默认继承父元素的一些样式，我们假设页面中的css如下(可以inline或从外部文件导入)：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure>
<p>生成的CSSOM树如下：</p>
<p><img src="../images/1537495994924.png" alt="1537495994924"></p>
<p>灰色的<code>font-size</code>表示这是一个继承属性。这里需要注意的是，CSSOM树中只包含了我们显式设置样式的元素，因为浏览器还有自己的默认样式</p>
<p>第三步把DOM和CSSOM结合在一起，生成渲染树(render tree)：</p>
<p>渲染树包含所有<strong>可见</strong>的元素及其显式设置的<strong>最终样式(computed style)</strong>，所以head和p元素下面的span不会出现在渲染树中：</p>
<p><img src="../images/1537498465699.png" alt="1537498465699"></p>
<p><span style="color: #999999;font-size:12px">注：图中的渲染树应该少了一个body的植树span元素</span></p>
<p>第四步计算所有元素在视窗(viewport)中的位置和大小：</p>
<p>在最终渲染之前需要计算每个元素的位置和大小，即它的<code>box model</code>，所有的尺寸css属性都要转为为像素，这一步也叫<em>回流(reflow)</em></p>
<p>最后一步就是渲染(pixel to screen)了，我们知道了元素的可见性及最终样式、大小、尺寸，剩下的事就是将它们画在屏幕上</p>
<p>这就是整个渲染过程，优化crp就是要尽量减少这5步所花的时间，让内容尽快呈现在用户面前。</p>
<h3 id="css的render-blocking特性"><a href="#css的render-blocking特性" class="headerlink" title="css的render blocking特性"></a>css的render blocking特性</h3><p>从上面我们可以看到，只有html和css都解析完了，我们才能构建渲染树，它们都是<em>渲染阻塞</em>(render blocking)的。html不用说了，没有它我们的页面从何而来，我们来说下css。如果没有样式，使用系统默认的样式，页面是很难看且基本不可用的。如果浏览器解析完DOM就直接渲染，等后面css再解析完了再渲染，就会出现页面的闪动问题：”Flash of Unstyled Content” (FOUC)，所以我们必须尽快构建CSSOM。因为CSSOM与DOM的构建是并行的，所以一般将css放在head里面，让它尽快开始构建，这样能将渲染树的构建尽量提前。</p>
<h3 id="javascript登场"><a href="#javascript登场" class="headerlink" title="javascript登场"></a>javascript登场</h3><p>页面当然少不了js，关于js的故事也最多。当页面引入js后，问题变复杂了，因为js太强大了：既能修改DOM有能修改CSSOM，还有人人闻之变色敬而远之的<code>document.write</code>，所以大家都听到一个故事了：浏览器在parse html过程中只要一遇到js，就要停止parse，直接此js加载并运行完成，这就是<strong>html block on js</strong>。其实这个故事只讲了一半，另一半是<strong>js block on css</strong>：如果当前有css还没有下载或解析完，js必须等待它们完成后才能执行！</p>
<p>前面说过，DOM和CSSOM是并行独立解析的，现在因为js的加入，它们之间发生了关联：DOM解析因js而阻塞，而js又因CSSOM而阻塞：</p>
<p><img src="../images/1537505638482.png" alt="1537505638482"></p>
<p>这也解释了为什么<strong>css在上，js在下(Stylesheets at the top, scripts at the bottom)</strong>：js放在body的末尾，这样就不会对DOM和CSSOM的构建进行干扰，让它们并行尽快完成；放在下面还有一个好处就是不通过<code>document.ready</code>事件也能直接引用所有DOM元素。</p>
<h4 id="说说defer和async"><a href="#说说defer和async" class="headerlink" title="说说defer和async"></a>说说defer和async</h4><p>前面说的html block on js中的js值的是<em>sync js</em>，js可以加上defer或async属性，大家应该都听说过，这里我们详细比较下这2个属性，首先它们有一个共同点：<strong>不会阻塞html的解析</strong>，不同点如下：</p>
<ul>
<li>defer js的执行在DOM和<strong>CSSOM</strong>全部构建完之后立即<em>按顺序执行</em>，而async js在加载完后马上执行，但是不保证执行顺序</li>
<li>DOMContentLoaded(DCL)在defer js执行完后再触发，而async js的执行和DCL触发时机无关。使用async js的话，DCL一般在DOM构建完后马上触发</li>
</ul>
<p>由此可见，如果不考虑js执行顺序，应该优先使用async js</p>
<h4 id="使用chrome-devtool中的Audits查看页面crp"><a href="#使用chrome-devtool中的Audits查看页面crp" class="headerlink" title="使用chrome devtool中的Audits查看页面crp"></a>使用chrome devtool中的Audits查看页面crp</h4><p>我们分别使用sync js，defer js，async js来测试下网页的渲染过程，特别是crp，页面如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>crp test - async<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"measureCRP()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- 分别使用defer，async测试 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"timing.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="../labs/crp-test-sync.html">sync js(默认行为)</a>：</p>
<p><img src="../images/1537520189100.png" alt="1537520189100"></p>
<p>可以看到js在crp中，且html经过了2次parse，中间被sync js阻塞了：</p>
<p><img src="../images/1537520778480.png" alt="1537520778480"></p>
<p>DCL(蓝线)也在js之后触发</p>
</li>
<li><p><a href="../labs/crp-test-defer.html">defer js</a></p>
<p><img src="../images/1537520878367.png" alt="1537520878367"></p>
<p>js不在crp中，但是DCL依然在js之后触发：</p>
<p><img src="../images/1537520964513.png" alt="1537520964513"></p>
</li>
<li><p><a href="../labs/crp-test-async.html">async js</a></p>
<p><img src="../images/1537520994931.png" alt="1537520994931"></p>
<p>js不在crp中，和预想的一样，且DCL也在js执行之前触发：</p>
<p><img src="../images/1537521049196.png" alt="1537521049196"></p>
<p>DCL在html parse完之后马上触发了</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想要提高页面加载和渲染速度，让用户尽快看到内容并交互，必须尽量减少crp的总体时间，控制crp中的资源数量</p>
<p>参考：</p>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/</a></p>
<p><a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/" target="_blank" rel="noopener">https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/crp/" data-id="cjn5lo78500037ovjpjo8hfdk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/">performance</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rendering" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/rendering/" class="article-date">
  <time datetime="2018-08-22T04:49:24.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/rendering/">浏览器渲染性能分析总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>这篇文章的主要素材来源于google开发文档：<a href="https://developers.google.com/web/fundamentals/performance/rendering/，算是做一个总结再加上自己的一些理解，做一个备忘录" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering/，算是做一个总结再加上自己的一些理解，做一个备忘录</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>显示器是以一个固定速度刷新屏幕的，一般是每秒60帧，我们可以想象浏览器里面有一个保存当前浏览器内容的渲染缓存，有一个独立的线程每隔大约16.6ms从这个缓存中把浏览器内容刷新到屏幕上，而浏览器的渲染便是刷新这个缓存。</p>
<p>浏览器绘制一帧主要需要经过下面5步：</p>
<p><img src="../images/1537324920067.png" alt="1537324920067"></p>
<ul>
<li><p>javascript</p>
<p>在javascript中可以做一些引起视觉变化的动作，如修改样式、操作dom等</p>
</li>
<li><p>style</p>
<p>这一步主要是根据选择器重新计算元素的最终的css样式，看哪些元素的样式发生了变化</p>
</li>
<li><p>layout</p>
<p>这个阶段计算元素几何布局的变化，如位置、大小等。值的注意的是，一个元素layout的变化可能会导致其他元素的连锁变化</p>
</li>
<li><p>paint</p>
<p>这一步就是绘制了：根据元素的位置、大小、样式进行绘制。一般来说，浏览器是分层(layer)绘制的，不同的元素可能被绘制到不同的层上</p>
</li>
<li><p>composite</p>
<p>这一步把绘制好的层根据层级关系(如z-index)组装起来</p>
</li>
</ul>
<p>不是每次重绘(update rendering)都会经过这完整的5步，这又分三种情况：</p>
<ul>
<li><p>修改layout相关属性，如width，这种情况下需要经过完整的步骤</p>
</li>
<li><p>修改的属性和layout无关，如边框颜色，这种情况下不需要重新计算layout，只需要重绘</p>
<p><img src="../images/1537326874563.png" alt="1537326874563"></p>
</li>
<li><p>有些属性的修改甚至都不需要重绘，直接组装即可</p>
<p><img src="../images/1537326942439.png" alt="1537326942439"></p>
<p>所以做视觉变化时我们应该优先使用这种属性</p>
</li>
</ul>
<p>下面我们依次分析每一步在性能优化时该注意哪些东西</p>
<h2 id="优化javascript的执行"><a href="#优化javascript的执行" class="headerlink" title="优化javascript的执行"></a>优化javascript的执行</h2><h3 id="避免js执行时间太长"><a href="#避免js执行时间太长" class="headerlink" title="避免js执行时间太长"></a>避免js执行时间太长</h3><p>提到js渲染优化，大家都知道一点，就是不要让js执行时间过长以免卡住主线程使得页面不能及时渲染更新，因为上面说的那几步都是在主线程中进行的。这个问题除了优化自身代码外有2种解决办法：</p>
<ul>
<li><p>web worker</p>
<p>比如你要做一个很费时的排序，可以扔给web worker去做，排好序了再返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = <span class="keyword">new</span> Worker(<span class="string">"sort-worker.js"</span>);</span><br><span class="line">dataSortWorker.postMesssage(dataToSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main thread is now free to continue working on other things...</span></span><br><span class="line"></span><br><span class="line">dataSortWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> sortedData = evt.data;</span><br><span class="line">   <span class="comment">// Update data on screen...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务分解</p>
<p>如果你的任务实在是要在主线程中做(如需要操作dom)，那么可以把任务分解成很多小步，把每一小步放到<code>requestAnimationRequest</code>(简称<strong>raf</strong>，后面会讲到)中进行，这样就不会阻塞页面的响应与渲染，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = breakBigTaskIntoMicroTasks(monsterTaskList);</span><br><span class="line">requestAnimationFrame(processTaskList);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processTaskList</span>(<span class="params">taskStartTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> taskFinishTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Assume the next task is pushed onto a stack.</span></span><br><span class="line">    <span class="keyword">var</span> nextTask = taskList.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process nextTask.</span></span><br><span class="line">    processTask(nextTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go again if there’s enough time to do the next task.</span></span><br><span class="line">    taskFinishTime = <span class="built_in">window</span>.performance.now();</span><br><span class="line">  &#125; <span class="keyword">while</span> (taskFinishTime - taskStartTime &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (taskList.length &gt; <span class="number">0</span>)</span><br><span class="line">    requestAnimationFrame(processTaskList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="用requestAnimationRequest来做视觉变化"><a href="#用requestAnimationRequest来做视觉变化" class="headerlink" title="用requestAnimationRequest来做视觉变化"></a>用requestAnimationRequest来做视觉变化</h3><p>前面提到了<code>raf</code>，这里我们正式介绍一下。简单地说，raf中注册的callback会在每一帧绘制开始的时候被调用。这里的<em>每一帧开始</em>可以理解为我们刚开始提到的屏幕以60帧每秒刷新的每一帧的开始，也是上一帧的结束点。就是说，从这个开始点开始，过大约16.6ms，屏幕会再次刷新。所以，你在raf中做的视觉变化(如样式修改，dom操作等)会在下一帧中得到展示(当然这些变化需要在16.6ms之内被浏览器更新)。</p>
<p>在raf出来之前，我们做视觉修改的时机和屏幕刷新时机是完全独立的，这会导致丢帧的情况，就是我我们的修改不会在下一帧显示出来，而是下下帧才显示出来，比如你用<code>setTimeout</code>在某个时间点做了修改，可能就会出现这种情形：</p>
<p><img src="../images/1537335693692.png" alt="1537335693692"></p>
<p>如果我们能把js中的视觉修改提前到当前帧的开始处，那就能在下一帧得到展示，而唯一能达到这个目的的做法就是使用raf</p>
<h2 id="减少样式计算的作用范围及复杂性"><a href="#减少样式计算的作用范围及复杂性" class="headerlink" title="减少样式计算的作用范围及复杂性"></a>减少样式计算的作用范围及复杂性</h2><p>这一节没啥好说的，一是使用简单的选择器，尽量使用class：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">.box:nth-last-child(-n+<span class="number">1</span>) .title &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">.final-box-title &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二是尽量减少需要重新计算样式的元素数量</p>
<h2 id="避免复杂的布局计算以及布局的反复计算-下面简称布局抖动"><a href="#避免复杂的布局计算以及布局的反复计算-下面简称布局抖动" class="headerlink" title="避免复杂的布局计算以及布局的反复计算(下面简称布局抖动)"></a>避免复杂的布局计算以及布局的反复计算(下面简称布局抖动)</h2><ul>
<li><p>尽量避免修改元素的布局</p>
<p>布局计算是重新计算元素的位置及大小，由于元素之间的排版关系紧密，布局计算的范围通常是整个文档：如果文档中的元素很多，这个过程需要花很长时间，所以第一原则是尽量避免修改元素的布局</p>
</li>
<li><p>避免强制布局同步(forced synchronous layouts)</p>
<p>前面提到，一般而言，我们渲染一帧需要经过以下5步：</p>
<p><img src="../images/1537347171681.png" alt="1537347171681"></p>
<p>layout只会计算一次，但是如果我们不注意的话，可能在javascript中就会发生layout计算，这种情况叫<em>强制布局计算</em>，也就是通常所说的<strong>回流</strong>。</p>
<p>关于布局，我们首先要认识的一件事就是在javascript中可以毫无代价地得到前一帧的布局信息，问题在于，如果你在获取之前改变了元素的样式，这个时候浏览器为了得到元素的最新的布局信息，必须先进行布局计算：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 改变元素样式</span></span><br><span class="line">  box.classList.add(<span class="string">'super-big'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gets the height of the box in pixels</span></span><br><span class="line">  <span class="comment">// and logs it out - 回流产生</span></span><br><span class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免布局抖动(layout thrashing)</p>
<p>比回流更可怕的是反复回流，看下以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Puts the browser into a read-write-read-write cycle.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">    paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次循环中需要得到box的宽度，同时设置其他元素的宽度；在下一次循环时，由于有元素的样式发生了变化，所以为了得到box的新的宽度必须重新计算布局，导致每次循环都要进行回流，这对性能是影响很大的</p>
</li>
</ul>
<h2 id="简化绘制复杂性及减小绘制区域"><a href="#简化绘制复杂性及减小绘制区域" class="headerlink" title="简化绘制复杂性及减小绘制区域"></a>简化绘制复杂性及减小绘制区域</h2><p>绘制一般是整个流程中最费时的一步，且除了<code>transform</code>和<code>opacity</code>属性外(下节会详细讲)，其他css属性的修改都会引起重绘。在重绘不可避免的情况下，可以考虑以下方法来减轻重绘的代价：</p>
<ul>
<li><p>将重绘的元素提升到新的层</p>
<p>前面提到过，浏览器是按层绘制的，绘制好所有层之后再把它们叠加合成生成最终的渲染结果。将重绘的元素提升到单独的层，这样就不会影响其他元素，提高渲染效率，这对那种移动的元素尤其有效。提升到独立的层的最有效的办法是使用<code>will-change</code>属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果浏览器不支持这个属性，可以使用下面的规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，太多的层也不好，加了之后需要处理验证</p>
</li>
<li><p>减小绘制区域</p>
</li>
<li><p>减小绘制复杂性</p>
<p>不用的css样式效果绘制效率不一样，比如说阴影绘制就比背景耗时，在效果相差不大时尽量考虑使用简单的css样式</p>
</li>
</ul>
<h2 id="坚持使用只影响合成的css属性-下面简称”合成相关”-及合理使用渲染层"><a href="#坚持使用只影响合成的css属性-下面简称”合成相关”-及合理使用渲染层" class="headerlink" title="坚持使用只影响合成的css属性(下面简称”合成相关”)及合理使用渲染层"></a>坚持使用只影响合成的css属性(下面简称”合成相关”)及合理使用渲染层</h2><p>上一节提过，有两个属性的修改不会引起重绘，这2个属性就是 transform 和 opacity：</p>
<p><img src="../images/1537350905247.png" alt="1537350905247"></p>
<p><img src="../images/1537351412290.png" alt="1537351412290"></p>
<p>所以在做动画时使用这2个属性是效率最高的：浏览器会把元素临时提升到独立层，不用绘制，直接合成。注意：如果需要将元素永久性地提升到独立层，需要使用上面提到的<code>will-change</code>或<code>transform</code>属性：</p>
<p><img src="../images/1537355072366.png" alt="1537355072366"></p>
<h2 id="考虑在事件处理中使用防节流机制"><a href="#考虑在事件处理中使用防节流机制" class="headerlink" title="考虑在事件处理中使用防节流机制"></a>考虑在事件处理中使用防节流机制</h2><ul>
<li><p>避免在事件处理中改变样式</p>
<p>事件处理是在<code>raf</code>之前执行的，如果你在事件处理中修改了样式，然后在raf中读取了样式，就可能导致前面提到的回流：</p>
<p><img src="../images/1537355384983.png" alt="1537355384983"></p>
<p>所以始终应该在raf中修改样式</p>
</li>
<li><p>事件节流</p>
<p>想scroll，size这种事件触发频率远远大于屏幕刷新频率的，在这种事件处理中做一些视觉变化操作是很浪费资源的，并可能导致界面卡死，解决办法还是一样：使用raf：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="built_in">window</span>.scrollY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span>;</span><br><span class="line">  requestAnimationFrame(readAndUpdatePage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/rendering/" data-id="cjn5lo78b00087ovjlps0z2ry" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/">performance</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tree-shaking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/tree-shaking/" class="article-date">
  <time datetime="2018-08-22T04:49:24.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/tree-shaking/">javascript优化之tree shaking</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简单地说，<code>tree shaking</code>就是不要将用不到的代码打包进来，举个例子，下面的文件定义了2个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主模块只用到了其中一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">'util.js'</span></span><br><span class="line">util.f1()</span><br></pre></td></tr></table></figure>
<p><code>f2</code>虽然没有被用到，但是打包的时候依然会包含进来，导致js文件变大。在webpack中，tree shaking是自动开启的，但是为了让它真正生效，需要你在其他方面稍微配合一下：</p>
<h3 id="只import你需要的代码"><a href="#只import你需要的代码" class="headerlink" title="只import你需要的代码"></a>只import你需要的代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; f1 &#125; <span class="keyword">from</span> <span class="string">'util.js'</span></span><br><span class="line">util.f1()</span><br></pre></td></tr></table></figure>
<h3 id="阻止babel将es6-module编译成commonJS"><a href="#阻止babel将es6-module编译成commonJS" class="headerlink" title="阻止babel将es6 module编译成commonJS"></a>阻止babel将es6 module编译成commonJS</h3><p>webpack的tree shaking只对es6 module其作用，所以我们要阻止babel先做转化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置sideEffects标记"><a href="#设置sideEffects标记" class="headerlink" title="设置sideEffects标记"></a>设置sideEffects标记</h3><p>有些模块的作用不是为了导出东西供其他模块使用，而是在被导入的时候做点其他事(如各种polyfills)，我们称这种模块是有<strong>副作用（side effects）</strong>，这种模块是不能移除的，这就是<code>sideEffects</code>的作用，它用来告诉一个包或项目中哪些文件具有副作用，需要在模块或项目的<code>package.json</code>中指定：</p>
<ul>
<li><p>所有文件都没有副作用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"webpack-tree-shaking-example"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某些文件具有副作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span>,</span><br><span class="line">    <span class="string">"*.css"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>做到以上几点，webpack的tree shaking就会生效，所以建议一直这样做，可以说百利而无一害</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/tree-shaking/" data-id="cjn5lo78f000c7ovj2am8pw6k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blob" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blob/" class="article-date">
  <time datetime="2018-08-12T04:49:24.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blob/">Blob类型用法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Blob一般指的是二进制块<code>Binary Large Object</code>的简称，用来存储大块不透明的任何数据，如图片、视频、字符串等等。<code>Blob</code>作为一种js类型，只有下面很少的属性和方法：</p>
<ul>
<li><p>属性</p>
<p><code>size</code>：blob的字节大小</p>
<p><code>type</code>：blob的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types" target="_blank" rel="noopener">MIME type</a></p>
</li>
<li><p>方法</p>
<p><code>slice</code>：截取blob的一段返回一个新的blob，算是blob的一种创建方法</p>
</li>
</ul>
<h2 id="Blob的构建"><a href="#Blob的构建" class="headerlink" title="Blob的构建"></a>Blob的构建</h2><h3 id="直接构建"><a href="#直接构建" class="headerlink" title="直接构建"></a>直接构建</h3><ul>
<li><p>Blob构造函数：<code>var aBlob = new Blob( array[, options]);</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aBlob = <span class="keyword">new</span> Blob([<span class="string">'my name'</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])], &#123; <span class="attr">type</span>: <span class="string">'text/plain'</span> &#125;)</span><br><span class="line">aBlob.size <span class="comment">// 10</span></span><br><span class="line">aBlob.type <span class="comment">// 'text/plain'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过BlobBuilder来构建(==已废弃，优先选择Blob构造函数==)</p>
</li>
</ul>
<h3 id="间接构建"><a href="#间接构建" class="headerlink" title="间接构建"></a>间接构建</h3><ul>
<li><p>从文件中读取：<code>&lt;input type=&quot;file&quot;&gt;</code></p>
<p>用户选择文件之后<code>input.files</code>就是一个<code>FileList</code>，里面的元素是<code>File</code>，<code>File</code>是<code>Blob</code>的子类型，具有其他一些额外的属性，如name，lastModifiedDate等：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Log information about a list of selected files</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fileinfo</span>(<span class="params">files</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123; <span class="comment">// files is an array-like object</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> f = files[i];</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(f.name, <span class="comment">// Name only: no path</span></span></span><br><span class="line"><span class="javascript">            f.size, f.type, <span class="comment">// size and type are Blob properties</span></span></span><br><span class="line"><span class="javascript">            f.lastModifiedDate); <span class="comment">// another File property</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Allow selection of multiple image files and pass them to fileinfo()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">multiple</span> <span class="attr">onchange</span>=<span class="string">"fileinfo(this.files)"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从XHR下载</p>
<p>可以通过ajax从服务器请求blob类型数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET the contents of the url as a Blob and pass it to the specified callback.</span></span><br><span class="line"><span class="comment">// This code is untested: no browsers supported this API when it was written.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// Create new XHR object</span></span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url); <span class="comment">// Specify URL to fetch</span></span><br><span class="line">    xhr.responseType = <span class="string">"blob"</span> <span class="comment">// We'd like a Blob, please</span></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// onload is easier than onreadystatechange</span></span><br><span class="line">    	callback(xhr.response); <span class="comment">// Pass the blob to our callback</span></span><br><span class="line">    &#125; <span class="comment">// Note .response, not .responseText</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>); <span class="comment">// Send the request now</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Blob的使用"><a href="#Blob的使用" class="headerlink" title="Blob的使用"></a>Blob的使用</h2><p>得到一个blob后，该如何使用它呢？</p>
<h3 id="直接发送给服务器端"><a href="#直接发送给服务器端" class="headerlink" title="直接发送给服务器端"></a>直接发送给服务器端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/server'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; &#125;;</span><br><span class="line">xhr.send(blob);</span><br></pre></td></tr></table></figure>
<h3 id="转化为URL来使用"><a href="#转化为URL来使用" class="headerlink" title="转化为URL来使用"></a>转化为URL来使用</h3><p>blob这个对象不能直接使用，可以转为为一个url，格式为：<code>blob:xxx</code>，使用这个url来引用这个blob。这个格式和<code>data:xxx</code>有点像，但是blob url没有包含任何编码信息，仅仅是作为一个唯一的key来引用这个blob；而data url则是编码后的数据本身。我们使用<code>URL.createObjectURL</code>来做转化，转化后的url可以用在一般的url可以使用的地方，如<code>img.src</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>); <span class="comment">// Create an &lt;img&gt; element</span></span><br><span class="line">img.src = URL.createObjectURL(file); <span class="comment">// Use Blob URL with &lt;img&gt;</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// When it loads</span></span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">100</span>; <span class="comment">// adjust its size and</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>); <span class="comment">// insert into document.</span></span><br><span class="line">    URL.revokeBlobURL(<span class="keyword">this</span>.src); <span class="comment">// But don't leak memory!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用FileReader读取blob的真实内容"><a href="#使用FileReader读取blob的真实内容" class="headerlink" title="使用FileReader读取blob的真实内容"></a>使用FileReader读取blob的真实内容</h3><p>上面提到的url只是一个blob的引用，并不是真实的内容，我们可以使用<code>FileReader</code>通过下面几个方法读取blob的真实内容：</p>
<ul>
<li><code>readAsArrayBuffer</code>：将blob读取为ArrayBuffer</li>
<li><code>readAsDataURL</code>：将blob读取为data url(注意：不是blob url)</li>
<li><code>readAsText</code>：将blob读取为字符串</li>
</ul>
<p>下面是一个读取图片预览的例子，通过<code>readAsDataURL</code>将图片转化为base64编码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">previewFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preview = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line">  <span class="keyword">var</span> file    = <span class="built_in">document</span>.querySelector(<span class="string">'input[type=file]'</span>).files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader  = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">  reader.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    preview.src = reader.result;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/blob/" data-id="cjn5lo77u00007ovjuxvi7xrz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-webgl-perspect" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/webgl-perspect/" class="article-date">
  <time datetime="2018-07-25T04:49:24.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/webgl-perspect/">透视投影解析 - 从建模到像素（WebGL）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道，在计算机图形学中物体从建模到展示在屏幕上需要经过大概下面几个坐标变换：</p>
<p><img src="..\images\steps.png" alt="steps"></p>
<p>我们以一个立方体的绘制来说明这一过程</p>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>这一步很简单，我们的立方体中心位于坐标系原点，默认情况下，相机也摆放在坐标系原点，和立方体处于同一个坐标系中，且使用的是右手坐标系：</p>
<p><img src="..\images\default cube.png" alt="default cube"></p>
<h2 id="摆放相机"><a href="#摆放相机" class="headerlink" title="摆放相机"></a>摆放相机</h2><p>立方体建好之后第二个问题就是从哪个方向来观察它，也就是相机的摆放。默认情况下相机位于原点，也就是立方体的中心，且是往Z轴的负方向进行观察，这个时候我们只能看到立方体的后面一面。为了便于观察，我们需要调整相机的位置。我们可以想象相机上面固定住xyz坐标轴，相机移动时，坐标轴也跟着移动。相机摆放完之后，我们要重新计算立方体在新的坐标系下的坐标，观察方向不变，还是沿着新的Z轴负方向：</p>
<p><img src="../images/default-cube-2.png" alt="default-cube-2"></p>
<p>已知原坐标系原点（O）、新坐标系原点（O’），及新坐标系y轴向量，就可以唯一确定这个变换，我们可以用一个函数调用表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新原点：(nOx, nOy, nOz), y轴向量：(upx, upy, upz)</span></span><br><span class="line">lookAt(nOx, nOy, nOz, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, upx, upy, upz)</span><br></pre></td></tr></table></figure>
<p>我们把<code>lookAt</code>确定的矩阵记为<code>Mv</code>,则立方体在新的相机坐标系下的坐标为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np = Mv * p</span><br></pre></td></tr></table></figure>
<h2 id="投影并裁减"><a href="#投影并裁减" class="headerlink" title="投影并裁减"></a>投影并裁减</h2><p>为了清除地看到投影后的图形，我们考虑一种简单的投影情况：相机沿着原Z轴正方向移动10个单位：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lookAt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="../images/1537254455887.png" alt="1537254455887"></p>
<p>我们以新的原点为聚焦点做透视投影，以上下裁减面夹角、近裁减面宽高比、近远裁减面距离指定透视投影参数：</p>
<p><img src="../images/1537255932260.png" alt="1537255932260"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPerspective(<span class="number">60</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>大家想想，这个时候我们的立方体在哪里呢？移动相机之后，立方体的前面的z坐标应该变成1 - 10 = 9，而后面的z坐标是-1 - 10 = -11，下面我们就看看经过这个投影之后，立方体前面在近裁减面上的投影位置及大小，通过简单作图可以看到：</p>
<p><img src="../images/1537257435923.png" alt="1537257435923"></p>
<p>可以看出立方体前面的成像高度为<code>1/9</code>，而近裁减面的高度为<code>tan(30)</code>，即$\sqrt{3}/3$，所以成像高度与近裁减面的高度比为：$\sqrt{3}/9$。</p>
<h2 id="输出到视口"><a href="#输出到视口" class="headerlink" title="输出到视口"></a>输出到视口</h2><p>到最后一步了，我们假设视口是一个<code>400x400</code>的窗口，在WebGL中，即一个canvas：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"webgl"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line">  Please use a browser that supports "canvas"</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们需要把近裁减面映射到这个canvas，按照前面的推算，我们可以得到立方体的前面最终渲染到这个canvas上的高度为$\sqrt{3}/9*400$，大概为77个像素，最终的渲染结果如下：</p>
<p><img src="../images/1537258598407.png" alt="1537258598407"></p>
<p>黑色背景即为整个canvas，通过手动测量，确实是77个像素，说明以上的推算过程是正确的，完整的示例在<a href="../webgl-guide/ch07/HelloCube.html">这里</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/webgl-perspect/" data-id="cjn5lo78h000f7ovjl4m0gznw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webgl/">webgl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/promise/" class="article-date">
  <time datetime="2018-07-12T04:49:24.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/promise/">promise精髓</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于promise的教程很多了，个人也看了不少，但心中总是没有一个清晰的脉络，总感觉知识点有点杂乱，希望在这里做个记录，简单清晰全面地总结promise的用法及注意点，不废话不深入，便于查阅</p>
<h2 id="创建及使用promise"><a href="#创建及使用promise" class="headerlink" title="创建及使用promise"></a>创建及使用promise</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 此函数立即执行</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (···) &#123;</span><br><span class="line">        resolve(value); <span class="comment">// success</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(reason); <span class="comment">// failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>promise创建的时候<strong>立即执行参数函数</strong></p>
<h3 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h3><p>promise有三种状态：</p>
<ul>
<li>Pending：代表初始状态，结果未知</li>
<li>Resolved：结果成功返回(<code>resolve</code>被调用)</li>
<li>Rejected：计算过程中发生错误(<code>reject</code>被调用<strong>或者</strong>参数函数执行过程中有异常抛出<code>throw</code>)</li>
</ul>
<p>如果promise变成Resolved或Rejected，我们称promise已经稳定了(settled)，稳定之后promise的状态不再变化：</p>
<p><img src="../../images/1538204868941.png" alt="1538204868941"></p>
<h3 id="消费-查询-使用promise"><a href="#消费-查询-使用promise" class="headerlink" title="消费/查询/使用promise"></a>消费/查询/使用promise</h3><p>一般都要关心promise的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onFulfilled处理resolved通知，onRejected处理rejected通知</span></span><br><span class="line">promise.then(onFulfilled, onRejected)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">/* fulfillment */</span> &#125;, error =&gt; &#123; <span class="comment">/* rejection */</span> &#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, error =&gt; &#123; <span class="comment">/* rejection */</span> &#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">promise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* rejection */</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以随时查询promise，无论它当时的状态是否是稳定的</p>
<h3 id="promise始终是异步的"><a href="#promise始终是异步的" class="headerlink" title="promise始终是异步的"></a>promise始终是异步的</h3><p>即使你查询promise的时候promise的状态已经是稳定的，你传递的通知函数也会被异步调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="其他创建promise的方法"><a href="#其他创建promise的方法" class="headerlink" title="其他创建promise的方法"></a>其他创建promise的方法</h3><h4 id="const-p-Promise-resolve-x"><a href="#const-p-Promise-resolve-x" class="headerlink" title="const p = Promise.resolve(x)"></a><code>const p = Promise.resolve(x)</code></h4><ul>
<li>x是普通值：p是一个处于Resolved状态且值为x的promise</li>
<li>x也是通过resolve创建的promise：p = x</li>
<li>x是其他方式创建的promise：p的状态取决于x的状态，就是说你查询p和查询x是等价的</li>
</ul>
<h4 id="const-p-Promise-reject-error"><a href="#const-p-Promise-reject-error" class="headerlink" title="const p = Promise.reject(error)"></a><code>const p = Promise.reject(error)</code></h4><p>返回一个处于Rejected状态且错误为error的promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myError = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.reject(myError).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err === myError)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="promise链接-Chaining-Promises"><a href="#promise链接-Chaining-Promises" class="headerlink" title="promise链接(Chaining Promises)"></a>promise链接(Chaining Promises)</h2><p>promise的一大优点是可以链接，因为<code>Promise.then</code>的返回值还是一个promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = p.then(onFulfilled, onRejected) <span class="comment">// q is a new promise</span></span><br></pre></td></tr></table></figure>
<p>所以我们可以继续查询q：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.then(onFulfilled, onRejected)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;)	<span class="comment">// resolved with what is returned by either onFulfilled or onRejected</span></span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;&#125;)	<span class="comment">// rejected if either onFulfilled or onRejected throw an exception</span></span><br></pre></td></tr></table></figure>
<h3 id="使用普通值来resolve-q"><a href="#使用普通值来resolve-q" class="headerlink" title="使用普通值来resolve q"></a>使用普通值来resolve q</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;	<span class="comment">// q is a promise resolved with 123</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value2); <span class="comment">// 123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用另一个promise来resolve-q"><a href="#使用另一个promise来resolve-q" class="headerlink" title="使用另一个promise来resolve q"></a>使用另一个promise来resolve q</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r;	<span class="comment">// r is a promise, q = r</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>resolve promise with normal value or another promise</code>状态示意图：</p>
<p><img src="../../images/1538211823168.png" alt="1538211823168"></p>
<p>###resolve q from <code>onRejected</code></p>
<p>从<code>onRejected</code>中返回的值一样可以用来resolve(==不是reject==) q：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Something went wrong, use a default value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Untitled.txt'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过抛出异常来reject-q-这个时候没有reject方法可以调用"><a href="#通过抛出异常来reject-q-这个时候没有reject方法可以调用" class="headerlink" title="通过抛出异常来reject q(这个时候没有reject方法可以调用)"></a>通过抛出异常来reject q(这个时候没有reject方法可以调用)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle error here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="错误随链接传递直到catch"><a href="#错误随链接传递直到catch" class="headerlink" title="错误随链接传递直到catch"></a>错误随链接传递直到catch</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1()</span><br><span class="line">.then(asyncFunc2)</span><br><span class="line">.then(asyncFunc3)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Something went wrong above</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="错误处理要点"><a href="#错误处理要点" class="headerlink" title="错误处理要点"></a>错误处理要点</h2><h3 id="不要使用then方法来捕获错误"><a href="#不要使用then方法来捕获错误" class="headerlink" title="不要使用then方法来捕获错误"></a>不要使用then方法来捕获错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don’t do this</span></span><br><span class="line"><span class="comment">// onRejected能捕获promise抛出的错误，但是不能捕获onFulfilled执行过程中抛出的异常</span></span><br><span class="line">promise.then(onFulfilled, onRejected)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的做法</span></span><br><span class="line">promise.then(onFulfilled).catch(onRejected)</span><br></pre></td></tr></table></figure>
<h3 id="注意区分reject和throw"><a href="#注意区分reject和throw" class="headerlink" title="注意区分reject和throw"></a>注意区分reject和throw</h3><p>一般来说reject抛出的是可预期的操作错误，如文件不存在、网络断开等；而throw抛出的是代码错误，如参数类型错误等</p>
<h3 id="Promise中抛出的异常不能被try-catch捕获"><a href="#Promise中抛出的异常不能被try-catch捕获" class="headerlink" title="Promise中抛出的异常不能被try-catch捕获"></a>Promise中抛出的异常不能被try-catch捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">a</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'err'</span> &#125;) </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>, e) <span class="comment">// 无法捕获上面的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="promise组合"><a href="#promise组合" class="headerlink" title="promise组合"></a>promise组合</h2><h3 id="Promise-all-promise1-promise2-…"><a href="#Promise-all-promise1-promise2-…" class="headerlink" title="Promise.all([promise1, promise2, …])"></a>Promise.all([promise1, promise2, …])</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    asyncFunc1(),</span><br><span class="line">    asyncFunc2(),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[result1, result2]</span>) =&gt;</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Receives first rejection among the Promises</span></span><br><span class="line">    ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race-promise1-promise2-…"><a href="#Promise-race-promise1-promise2-…" class="headerlink" title="Promise.race([promise1, promise2, …])"></a>Promise.race([promise1, promise2, …])</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    httpGet(<span class="string">'http://example.com/file.txt'</span>),</span><br><span class="line">    delay(<span class="number">5000</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Timed out'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; ··· &#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123; ··· &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="两个额外的promise函数"><a href="#两个额外的promise函数" class="headerlink" title="两个额外的promise函数"></a>两个额外的promise函数</h2><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>前面说过promise中抛出的异常外界捕获不到，所以我们解决这个问题(始终加上catch也不行，catch中也可能抛出异常)，可以在promise上定义一个<code>done</code>方法，然后跟在promise链最后面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    asyncFunc()</span><br><span class="line">    .then(f1)</span><br><span class="line">    .catch(r1)</span><br><span class="line">    .then(f2)</span><br><span class="line">    .done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样来定义done方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Throw an exception globally</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>仿造<code>try-catch-finally</code>我们可以在promise上定义一个finally方法，使得无论最后promise状态如何，始终执行一个callback：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="comment">// We don’t invoke the callback in here,</span></span><br><span class="line">    <span class="comment">// because we want then() to handle its exceptions</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        <span class="comment">// Callback fulfills =&gt; continue with receiver’s fulfillment or rejection</span></span><br><span class="line">        <span class="comment">// Callback rejects =&gt; pass on that rejection (then() has no 2nd parameter!)</span></span><br><span class="line">        value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>async &amp; await本质上是promise的语法糖，掌握了promise基本知道它们的用法了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc().then(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: Problem!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async可可以直接返回另一个promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc().then(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>));</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err)); <span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> otherAsyncFunc1();</span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> otherAsyncFunc2();</span><br><span class="line">    <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc1()</span><br><span class="line">    .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1);</span><br><span class="line">        <span class="keyword">return</span> otherAsyncFunc2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ])</span><br><span class="line">    .then([result1, result2] =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/promise/" data-id="cjn5lo78d000a7ovjjq9d4rat" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise/">promise</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-promise-race-transform" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/promise-race-transform/" class="article-date">
  <time datetime="2018-05-12T04:49:24.000Z" itemprop="datePublished">2018-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/promise-race-transform/">Promise.race一种变形：any resolve =&gt; resolve, all reject =&gt; reject实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道，<code>pr = Promise.race[promises]</code>的意思是promises中任何一个resolve会导致pr变成resolve，任何一个reject会导致pr变成reject，但是有时候我们需要这样的逻辑：resolve和race一样，但是必须是promises中所有的都是reject，pr才变成reject，该怎么办？偶然在网上看到一个实现，很精妙，估记录一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.race is no good to us because it rejects if</span></span><br><span class="line"><span class="comment">// a promise rejects before fulfilling. Let's make a proper</span></span><br><span class="line"><span class="comment">// race function:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAny</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// make sure promises are all promises</span></span><br><span class="line">    promises = promises.map(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// resolve this promise as soon as one resolves</span></span><br><span class="line">    promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.then(resolve));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// reject if all promises reject</span></span><br><span class="line">    promises.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.catch(<span class="function"><span class="params">()</span> =&gt;</span> b))</span><br><span class="line">      .catch(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">"All failed"</span>)));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的关键是<code>reduce</code>语句，假设我们传进来的<code>promises</code>是<code>[a, b, c, d]</code>，这条语句等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.catch(<span class="function"><span class="params">()</span> =&gt;</span> b).catch(<span class="function"><span class="params">()</span> =&gt;</span> c).catch(<span class="function"><span class="params">()</span> =&gt;</span> d)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">"All failed"</span>)));</span><br></pre></td></tr></table></figure>
<p>如果最后一个catch被执行，说明前面所有的catch都被执行了，而前面的catch函数都是返回下一个promise，这说明每个promise都是reject状态</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinge.red/promise-race-transform/" data-id="cjn5lo78a00077ovj8lujfgne" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise/">promise</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwa/">pwa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webgl/">webgl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/performance/" style="font-size: 20px;">performance</a> <a href="/tags/promise/" style="font-size: 15px;">promise</a> <a href="/tags/pwa/" style="font-size: 10px;">pwa</a> <a href="/tags/webgl/" style="font-size: 10px;">webgl</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/offline-cookbook/">offline-cookbook总结</a>
          </li>
        
          <li>
            <a href="/csrf-xss/">CSRF和XSS扫盲</a>
          </li>
        
          <li>
            <a href="/code-splitting/">javascript优化之code splitting</a>
          </li>
        
          <li>
            <a href="/crp/">深入理解浏览器关键渲染路径(critical render path)及其优化</a>
          </li>
        
          <li>
            <a href="/rendering/">浏览器渲染性能分析总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wang xiantong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>